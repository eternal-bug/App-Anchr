[% INCLUDE header.tt2 %]

#----------------------------#
# Run
#----------------------------#

START_TIME=$(date +%s)
save START_TIME

NUM_THREADS=[% opt.parallel %]
save NUM_THREADS

BBTOOLS_RESOURCES=$(brew --prefix)/Cellar/$(brew list --versions bbtools | sed 's/ /\//')/resources
rm -f temp.fq.gz;

#----------------------------#
# Pipeline
#----------------------------#
# from bbmap/bbmap/pipelines/assemblyPipeline.sh

# Reorder reads for speed of subsequent phases
# As we're going to precess reads from different sources, don't dedupe here.
# 1. dedupe, Remove duplicate reads.
# 2. optical, mark or remove optical duplicates only. Normal Illumina names needed.
log_info "clumpify"
if [ ! -e clumpify.fq.gz ]; then
    clumpify.sh \
        in=[% args.0 %] \
[% IF args.1 -%]
        in2=[% args.1 %] \
[% END -%]
        out=clumpify.fq.gz \
[% IF opt.dedupe -%]
        dedupe dupesubs=0 \
[% END -%]
        threads=[% opt.parallel %]
fi
rm -f temp.fq.gz; ln -s clumpify.fq.gz temp.fq.gz

[% IF opt.tile -%]
# Remove low-quality reads by positions in flowcell
log_info "filteredbytile"
if [ ! -e filteredbytile.fq.gz ]; then
    filterbytile.sh \
        in=temp.fq.gz \
        out=filteredbytile.fq.gz \
        threads=[% opt.parallel %]
fi
rm temp.fq.gz; ln -s filteredbytile.fq.gz temp.fq.gz
[% END -%]

[% IF opt.sample -%]
# Down sampling reads. 300x is fine
log_info "sample with reformat.sh"
if [ ! -e sample.fq.gz ]; then
    reformat.sh \
        in=temp.fq.gz \
        out=sample.fq.gz \
        samplebasestarget=[% opt.sample %] \
        threads=[% opt.parallel %]
fi
rm temp.fq.gz; ln -s sample.fq.gz temp.fq.gz
[% END -%]

# Trim 5' adapters and discard reads with Ns
# Use bbduk.sh to quality and length trim the Illumina reads and remove adapter sequences
# 1. ftm = 5, right trim read length to a multiple of 5
# 2. k = 23, Kmer length used for finding contaminants
# 3. ktrim=r, Trim reads to remove bases matching reference kmers to the right
# 4. mink=7, look for shorter kmers at read tips down to 7 bps
# 5. hdist=1, hamming distance for query kmers
# 6. tbo, trim adapters based on where paired reads overlap
# 7. tpe, when kmer right-trimming, trim both reads to the minimum length of either
# 8. qtrim=r, trim read right ends to remove bases with low quality
# 9. trimq=15, regions with average quality below 15 will be trimmed.
# 10. minlen=60, reads shorter than 60 bps after trimming will be discarded.
log_info "trim with bbduk.sh"
if [ ! -e trim.fq.gz ]; then
    bbduk.sh \
        in=temp.fq.gz \
        out=trim.fq.gz \
        ref=[% opt.adapter %] \
        maxns=0 ktrim=r k=[% opt.trimk %] mink=11 hdist=1 tbo tpe \
        minlen=[% opt.len.split('\s+').0 %] ftm=5 ordered \
        stats=trim.stats.txt overwrite \
        threads=[% opt.parallel %]
fi
rm temp.fq.gz; ln -s trim.fq.gz temp.fq.gz

# Remove synthetic artifacts, spike-ins and 3' adapters by kmer-matching.
log_info "filter with bbduk.sh"
if [ ! -e filter.fq.gz ]; then
    bbduk.sh \
        in=temp.fq.gz \
        out=filter.fq.gz \
        ref=[% FOREACH filter IN opt.filter %][% IF filter == 'adapter' %]${BBTOOLS_RESOURCES}/adapters.fa,[% END %][% IF filter == 'phix' %]${BBTOOLS_RESOURCES}/phix174_ill.ref.fa.gz,[% END %][% IF filter == 'artifact' %]${BBTOOLS_RESOURCES}/sequencing_artifacts.fa.gz,[% END %][% END %] \
        k=[% opt.matchk %] hdist=1 ordered cardinality \
        stats=filter.stats.txt overwrite \
        threads=[% opt.parallel %]
fi
rm temp.fq.gz; ln -s filter.fq.gz temp.fq.gz

# Revert to normal pair-end fastq files
log_info "re-pair with repair.sh"
if [ ! -e R1.trim.fq.gz ]; then
[% IF args.1 -%]
    repair.sh \
        in=temp.fq.gz \
        out=R1.clean.fq.gz \
        out2=R2.clean.fq.gz \
        outs=Rs.clean.fq.gz \
        repair \
        threads=[% opt.parallel %]
[% ELSE -%]
    cp -L temp.fq.gz R1.clean.fq.gz
[% END -%]
fi

#----------------------------#
# Sickle
#----------------------------#
log_info "sickle ::: Qual [% opt.qual %] ::: Len [% opt.len %]"
parallel --no-run-if-empty --linebuffer -k -j 2 "
    mkdir -p Q{1}L{2}
    cd Q{1}L{2}

    printf '==> Qual-Len: %s\n'  Q{1}L{2}
    if [ -e R1.sickle.fq.gz ]; then
        echo '    R1.sickle.fq.gz already presents'
        exit;
    fi

[% IF args.1 -%]
    sickle pe \
        -t sanger \
        -q {1} \
        -l {2} \
        -f ../R1.clean.fq.gz \
        -r ../R2.clean.fq.gz \
        -o R1.sickle.fq \
        -p R2.sickle.fq \
        -s Rs.sickle.fq
    sickle se \
        -t sanger \
        -q {1} \
        -l {2} \
        -f ../Rs.clean.fq.gz \
        -o Rs.temp.fq
    cat Rs.temp.fq >> Rs.sickle.fq
    rm Rs.temp.fq
[% ELSE -%]
    sickle se \
        -t sanger \
        -q {1} \
        -l {2} \
        -f ../R1.clean.fq.gz \
        -o R1.sickle.fq
[% END -%]

    pigz *.sickle.fq
    " ::: [% opt.qual %] ::: [% opt.len %]

exit 0
